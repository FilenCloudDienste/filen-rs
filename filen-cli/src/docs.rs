//! This function generates documentation for the CLI in markdown format,
//! or prints help texts in-app.
//! It takes the outline of the documentation (none of the text!),
//! then fills in the actual documentation content from the CLI doc fragments,
//! and the command help texts generated by clap.
//! The doc fragments are doc comments in the source code marked with
//! `[cli-doc] <fragment-id>`, right next to the code they document.

use std::{collections::HashSet, path::PathBuf, sync::LazyLock};

use anyhow::{Context, Result};
use clap::{CommandFactory, builder::Styles};
use filen_macros::extract_cli_doc_fragments;

use crate::{CliArgs, ui::UI};

extract_cli_doc_fragments!();

#[derive(Debug)]
enum DocElement {
	Heading1(&'static str),
	DocFragment(&'static str),
	CommandHelp(&'static str),
	GlobalOptions,
}

#[derive(Debug)]
enum ParsedDocElement {
	Heading1 { text: String },
	DocFragment { text: String },
	CommandHelp { command: Box<clap::Command> },
	GlobalOptions,
}

#[derive(Debug)]
struct DocSection {
	id: &'static str,
	title: &'static str,
	elements: Vec<DocElement>,
}

#[derive(Debug)]
struct ParsedDocSection {
	id: String,
	title: String,
	elements: Vec<ParsedDocElement>,
}

static PARSED_DOC_OUTLINE: LazyLock<Result<Vec<ParsedDocSection>>> = LazyLock::new(|| {
	let doc_outline = [
		DocSection {
			id: "usage",
			title: "Usage",
			elements: vec![
				DocElement::DocFragment("main-usage"),
				DocElement::Heading1("Options"),
				DocElement::GlobalOptions,
				DocElement::Heading1("Updates"),
				DocElement::DocFragment("updates"),
				DocElement::Heading1("Commands"),
				DocElement::CommandHelp("help"),
				DocElement::CommandHelp("exit"),
			],
		},
		DocSection {
			id: "auth",
			title: "Authentication",
			elements: vec![
				DocElement::DocFragment("auth-methods"),
				DocElement::CommandHelp("export-auth-config"),
				DocElement::CommandHelp("logout"),
			],
		},
		DocSection {
			id: "access-files",
			title: "Accessing Files",
			elements: vec![
				DocElement::CommandHelp("cd"),
				DocElement::CommandHelp("ls"),
				DocElement::CommandHelp("cat"),
				DocElement::CommandHelp("head"),
				DocElement::CommandHelp("tail"),
				DocElement::CommandHelp("stat"),
				DocElement::CommandHelp("mkdir"),
				DocElement::CommandHelp("rm"),
				DocElement::CommandHelp("mv"),
				DocElement::CommandHelp("cp"),
				DocElement::CommandHelp("favorite"),
				DocElement::CommandHelp("unfavorite"),
				DocElement::CommandHelp("list-trash"),
				DocElement::CommandHelp("empty-trash"),
			],
		},
		DocSection {
			id: "mounting",
			title: "Mounting a Virtual Drive",
			elements: vec![
				DocElement::CommandHelp("mount"),
				// todo: missing more extensive mount help text
			],
		},
	];

	// parse doc elements
	let mut commands = CliArgs::command();
	let mut used_commands = HashSet::new();
	let cli_doc_fragments = get_cli_doc_fragments();
	let mut used_doc_fragments = HashSet::new();
	let mut used_global_options = false;
	let parsed_outline = doc_outline
		.iter()
		.map(|section| {
			let parsed_elements = section
				.elements
				.iter()
				.map(|element| match element {
					DocElement::Heading1(text) => Ok(ParsedDocElement::Heading1 {
						text: text.to_string(),
					}),
					DocElement::DocFragment(fragment_id) => {
						if let Some(fragment) = cli_doc_fragments
							.iter()
							.find(|fragment| fragment.id == *fragment_id)
						{
							used_doc_fragments.insert(fragment.id.clone());
							Ok(ParsedDocElement::DocFragment {
								text: fragment.content.to_string(),
							})
						} else {
							Err(anyhow::anyhow!(
								"Doc fragment with id '{}' not found",
								fragment_id
							))
						}
					}
					DocElement::CommandHelp(command) => {
						if let Some(command) = commands.find_subcommand_mut(command) {
							used_commands.insert(command.get_name().to_string());
							Ok(ParsedDocElement::CommandHelp {
								command: Box::new(command.clone()),
							})
						} else {
							Err(anyhow::anyhow!(
								"Command '{}' not found in CLI structure",
								command
							))
						}
					}
					DocElement::GlobalOptions => {
						used_global_options = true;
						Ok(ParsedDocElement::GlobalOptions)
					}
				})
				.collect::<Result<Vec<ParsedDocElement>>>()
				.with_context(|| {
					format!("Failed to parse doc elements for section '{}'", section.id)
				})?;
			Ok(ParsedDocSection {
				id: section.id.to_string(),
				title: section.title.to_string(),
				elements: parsed_elements,
			})
		})
		.collect::<Result<Vec<ParsedDocSection>>>()?;

	// ensure that all doc fragments, commands and global options were used
	let unused_doc_fragments = cli_doc_fragments
		.iter()
		.map(|fragment| &fragment.id)
		.filter(|id| !used_doc_fragments.contains(id.as_str()))
		.collect::<Vec<&String>>();
	if !unused_doc_fragments.is_empty() {
		return Err(anyhow::anyhow!(
			"Some CLI doc fragments were not used in the markdown docs: {:?}",
			unused_doc_fragments
		));
	}
	let unused_commands = commands
		.get_subcommands()
		.map(|cmd| cmd.get_name().to_string())
		.filter(|name| !used_commands.contains(name))
		.collect::<Vec<String>>();
	if !unused_commands.is_empty() {
		return Err(anyhow::anyhow!(
			"Some CLI commands were not documented in the markdown docs: {:?}",
			unused_commands
		));
	}
	if !used_global_options {
		return Err(anyhow::anyhow!(
			"Global CLI options were not documented in the markdown docs"
		));
	}

	// ensure ids are unique among sections, doc fragments and commands
	let mut ids = doc_outline
		.iter()
		.flat_map(|section| {
			let mut ids = vec![section.id];
			ids.extend(section.elements.iter().filter_map(|element| match element {
				DocElement::DocFragment(fragment_id) => Some(fragment_id),
				DocElement::CommandHelp(command_id) => Some(command_id),
				_ => None,
			}));
			ids
		})
		.collect::<Vec<&'static str>>();
	ids.sort();
	for i in 1..ids.len() {
		if ids[i] == ids[i - 1] {
			return Err(anyhow::anyhow!("Duplicate doc id found: '{}'", ids[i]));
		}
	}

	Ok(parsed_outline)
});

// markdown docs

pub(crate) fn generate_markdown_docs() -> Result<()> {
	let output_dir = PathBuf::from("filen-cli-markdown-docs");
	std::fs::create_dir_all(&output_dir).context("Failed to create markdown docs output dir")?;

	PARSED_DOC_OUTLINE
		.as_ref()
		.map_err(|e| anyhow::anyhow!("Failed to parse CLI doc outline: {}", e))?
		.iter()
		.enumerate()
		.try_for_each(|(i, section)| {
			let elements = section
				.elements
				.iter()
				.map(|element| match element {
					ParsedDocElement::Heading1 { text } => format!("## {}", text),
					ParsedDocElement::DocFragment { text } => text.to_string(),
					ParsedDocElement::CommandHelp { command } => {
						format_markdown_command_help(&mut command.clone())
					}
					ParsedDocElement::GlobalOptions => CliArgs::command()
						.clone()
						.help_template("{options}")
						.render_help()
						.to_string()
						.lines()
						.map(|l| {
							if l.trim().starts_with("-") {
								format!("- `{}`", l.trim())
							} else {
								format!("  {}", l.trim())
							}
						})
						.collect::<Vec<String>>()
						.join("  \n"),
				})
				.collect::<Vec<String>>();
			let mut markdown_content = String::new();
			markdown_content.push_str(&format!("# {}\n\n", section.title));
			markdown_content.push_str(&elements.join("\n\n"));

			std::fs::write(
				output_dir.join(format!("{:02}-{}.md", i + 1, section.id)),
				markdown_content,
			)
			.with_context(|| format!("Failed to write markdown doc file '{}'", section.id))
		})?;

	Ok(())
}

fn format_markdown_command_help(cmd: &mut clap::Command) -> String {
	let render_help_text_template = |template: &'static str| {
		cmd.clone()
			.styles(
				Styles::styled()
					.literal(anstyle::Style::new())
					.header(anstyle::Style::new())
					.usage(anstyle::Style::new()),
			)
			.help_template(template)
			.render_help()
			.to_string()
	};
	let usage = render_help_text_template("{usage}");
	let about = render_help_text_template("{about}");
	let args = render_help_text_template("{positionals}\n{options}")
		.lines()
		.filter(|l| !l.contains("--help")) // filter out help flag line that is erraneously included by clap
		.map(|l| {
			let parts = l
				.trim()
				.split("  ")
				.map(|part| part.trim())
				.filter(|part| !part.is_empty())
				.collect::<Vec<&str>>();
			if parts.len() == 2 {
				format!("  \n> ðŸ Š `{}` {}", parts[0], parts[1])
			} else {
				log::warn!(
					"Unexpected args line format: '{}' for command '{}' (maybe it misses a description)",
					l,
					cmd.get_name()
				);
				format!("  \n> ðŸ Š {}", l.trim())
			}
		})
		.collect::<Vec<_>>();
	format!(
		"> `{}`  \n> {}{}",
		usage.trim(),
		about.trim(),
		args.join("")
	)
}

// in-app docs

pub(crate) fn print_in_app_docs(
	ui: &mut UI,
	section_or_command_or_topic: Option<String>,
) -> Result<()> {
	const MAIN_SECTION: &str = "usage";
	let parsed_doc_outline = PARSED_DOC_OUTLINE
		.as_ref()
		.map_err(|e| anyhow::anyhow!("Failed to parse CLI doc outline: {}", e))?;
	let command_or_topic = section_or_command_or_topic.unwrap_or(String::from(MAIN_SECTION));
	if let Some(section) = parsed_doc_outline.iter().find(|s| s.id == command_or_topic) {
		// doc section
		ui.print(&UI::format_text_heading(&section.title));
		ui.print("");
		let elements = section
			.elements
			.iter()
			.map(|element| match element {
				ParsedDocElement::Heading1 { text } => UI::format_text_heading(text),
				ParsedDocElement::DocFragment { text } => text.to_string(),
				ParsedDocElement::CommandHelp { command } => {
					UI::format_text_blockquote(&UI::format_command_help(&mut command.clone()))
				}
				ParsedDocElement::GlobalOptions => UI::format_global_options_help(),
			})
			.collect::<Vec<String>>();
		ui.print(&elements.join("\n\n"));

		// print table of contents for main section
		if command_or_topic == MAIN_SECTION {
			ui.print("");
			ui.print(&UI::format_text_heading("More help topics"));
			ui.print("");
			ui.print(
				&parsed_doc_outline
					.iter()
					.filter_map(|section| {
						if section.id != MAIN_SECTION {
							Some(format!(
								"{}  {} {}",
								dialoguer::console::style(&section.title).underlined(),
								dialoguer::console::style("â†’").dim(),
								dialoguer::console::style(format!("help {}", section.id)).green()
							))
						} else {
							None
						}
					})
					.collect::<Vec<String>>()
					.join("\n"),
			);
		}
	} else if let Some(doc_fragment) = get_cli_doc_fragments()
		.iter()
		.find(|fragment| fragment.id == command_or_topic)
	{
		// doc fragment
		ui.print(&doc_fragment.content);
	} else if let Some(command) = CliArgs::command().find_subcommand_mut(&command_or_topic) {
		// command help
		ui.print(&UI::format_command_help(&mut command.clone()));
	} else {
		ui.print_failure(&format!("No help found for '{}'", command_or_topic));
	}

	Ok(())
}
