//! This function generates documentation for the CLI in markdown format,
//! or prints help texts in-app.
//! It takes the outline of the documentation (none of the text!),
//! then fills in the actual documentation content from the CLI doc fragments,
//! and the command help texts generated by clap.
//! The doc fragments are doc comments in the source code marked with
//! `[cli-doc] <fragment-id>`, right next to the code they document.

use std::{collections::HashSet, path::PathBuf, sync::LazyLock};

use anyhow::{Context, Result};
use clap::CommandFactory;
use filen_macros::extract_cli_doc_fragments;

use crate::{CliArgs, ui::UI};

extract_cli_doc_fragments!();

#[derive(Debug)]
enum DocElement {
	Heading1(&'static str),
	DocFragment(&'static str),
	CommandHelp(&'static str),
}

#[derive(Debug)]
enum ParsedDocElement {
	Heading1 { text: String },
	DocFragment { text: String },
	CommandHelp { command: Box<clap::Command> },
}

#[derive(Debug)]
struct DocSection {
	id: &'static str,
	title: &'static str,
	elements: Vec<DocElement>,
}

#[derive(Debug)]
struct ParsedDocSection {
	id: String,
	title: String,
	elements: Vec<ParsedDocElement>,
}

static PARSED_DOC_OUTLINE: LazyLock<Result<Vec<ParsedDocSection>>> = LazyLock::new(|| {
	let doc_outline = [
		DocSection {
			id: "usage",
			title: "Usage",
			elements: vec![
				DocElement::DocFragment("main-usage"),
				DocElement::CommandHelp("help"),
				DocElement::CommandHelp("exit"),
				DocElement::Heading1("Updates"),
				DocElement::DocFragment("updates"),
				DocElement::Heading1("Mounting"),
				DocElement::CommandHelp("mount"),
			],
		},
		DocSection {
			id: "auth",
			title: "Authentication",
			elements: vec![
				DocElement::DocFragment("auth-methods"),
				DocElement::CommandHelp("export-auth-config"),
				DocElement::CommandHelp("logout"),
			],
		},
		DocSection {
			id: "access-files",
			title: "Accessing Files",
			elements: vec![
				DocElement::CommandHelp("cd"),
				DocElement::CommandHelp("ls"),
				DocElement::CommandHelp("cat"),
				DocElement::CommandHelp("head"),
				DocElement::CommandHelp("tail"),
				DocElement::CommandHelp("stat"),
				DocElement::CommandHelp("mkdir"),
				DocElement::CommandHelp("rm"),
				DocElement::CommandHelp("mv"),
				DocElement::CommandHelp("cp"),
				DocElement::CommandHelp("favorite"),
				DocElement::CommandHelp("unfavorite"),
				DocElement::CommandHelp("list-trash"),
				DocElement::CommandHelp("empty-trash"),
			],
		},
	];

	// parse doc elements
	let mut commands = CliArgs::command();
	let mut used_commands = HashSet::new();
	let cli_doc_fragments = get_cli_doc_fragments();
	let mut used_doc_fragments = HashSet::new();
	let parsed_outline = doc_outline
		.iter()
		.map(|section| {
			let parsed_elements = section
				.elements
				.iter()
				.map(|element| match element {
					DocElement::Heading1(text) => Ok(ParsedDocElement::Heading1 {
						text: text.to_string(),
					}),
					DocElement::DocFragment(fragment_id) => {
						if let Some(fragment) = cli_doc_fragments
							.iter()
							.find(|fragment| fragment.id == *fragment_id)
						{
							used_doc_fragments.insert(fragment.id.clone());
							Ok(ParsedDocElement::DocFragment {
								text: fragment.content.to_string(),
							})
						} else {
							Err(anyhow::anyhow!(
								"Doc fragment with id '{}' not found",
								fragment_id
							))
						}
					}
					DocElement::CommandHelp(command) => {
						if let Some(command) = commands.find_subcommand_mut(command) {
							used_commands.insert(command.get_name().to_string());
							Ok(ParsedDocElement::CommandHelp {
								command: Box::new(command.clone()),
							})
						} else {
							Err(anyhow::anyhow!(
								"Command '{}' not found in CLI structure",
								command
							))
						}
					}
				})
				.collect::<Result<Vec<ParsedDocElement>>>()
				.with_context(|| {
					format!("Failed to parse doc elements for section '{}'", section.id)
				})?;
			Ok(ParsedDocSection {
				id: section.id.to_string(),
				title: section.title.to_string(),
				elements: parsed_elements,
			})
		})
		.collect::<Result<Vec<ParsedDocSection>>>()?;

	// ensure that all doc fragments and commands were used
	let unused_doc_fragments = cli_doc_fragments
		.iter()
		.map(|fragment| &fragment.id)
		.filter(|id| !used_doc_fragments.contains(id.as_str()))
		.collect::<Vec<&String>>();
	if !unused_doc_fragments.is_empty() {
		return Err(anyhow::anyhow!(
			"Some CLI doc fragments were not used in the markdown docs: {:?}",
			unused_doc_fragments
		));
	}
	let unused_commands = commands
		.get_subcommands()
		.map(|cmd| cmd.get_name().to_string())
		.filter(|name| !used_commands.contains(name))
		.collect::<Vec<String>>();
	if !unused_commands.is_empty() {
		return Err(anyhow::anyhow!(
			"Some CLI commands were not documented in the markdown docs: {:?}",
			unused_commands
		));
	}

	// ensure ids are unique among sections, doc fragments and commands
	let mut ids = doc_outline
		.iter()
		.flat_map(|section| {
			let mut ids = vec![section.id];
			ids.extend(section.elements.iter().filter_map(|element| match element {
				DocElement::DocFragment(fragment_id) => Some(fragment_id),
				DocElement::CommandHelp(command_id) => Some(command_id),
				_ => None,
			}));
			ids
		})
		.collect::<Vec<&'static str>>();
	ids.sort();
	for i in 1..ids.len() {
		if ids[i] == ids[i - 1] {
			return Err(anyhow::anyhow!("Duplicate doc id found: '{}'", ids[i]));
		}
	}

	Ok(parsed_outline)
});
// todo: also specify here where global flags are documented?

// markdown docs

pub(crate) fn generate_markdown_docs() -> Result<()> {
	let output_dir = PathBuf::from("filen-cli-markdown-docs");
	std::fs::create_dir_all(&output_dir).context("Failed to create markdown docs output dir")?;

	PARSED_DOC_OUTLINE
		.as_ref()
		.map_err(|e| anyhow::anyhow!("Failed to parse CLI doc outline: {}", e))?
		.iter()
		.enumerate()
		.try_for_each(|(i, section)| {
			let elements = section
				.elements
				.iter()
				.map(|element| match element {
					ParsedDocElement::Heading1 { text } => format!("## {}", text),
					ParsedDocElement::DocFragment { text } => text.to_string(),
					ParsedDocElement::CommandHelp { command } => {
						format!("```\n{}\n```", command.clone().render_long_help().ansi())
					}
				})
				.collect::<Vec<String>>();
			let mut markdown_content = String::new();
			markdown_content.push_str(&format!("# {}\n\n", section.title));
			markdown_content.push_str(&elements.join("\n\n"));

			std::fs::write(
				output_dir.join(format!("{:02}-{}.md", i, section.id)), // todo: is this how Docusaurus wants it?
				markdown_content,
			)
			.with_context(|| format!("Failed to write markdown doc file '{}'", section.id))
		})?;

	Ok(())
}

// in-app docs

pub(crate) fn print_in_app_docs(
	ui: &mut UI,
	section_or_command_or_topic: Option<String>,
) -> Result<()> {
	const MAIN_SECTION: &str = "usage";
	let parsed_doc_outline = PARSED_DOC_OUTLINE
		.as_ref()
		.map_err(|e| anyhow::anyhow!("Failed to parse CLI doc outline: {}", e))?;
	let command_or_topic = section_or_command_or_topic.unwrap_or(String::from(MAIN_SECTION));
	if let Some(section) = parsed_doc_outline.iter().find(|s| s.id == command_or_topic) {
		// doc section
		ui.print(&UI::format_text_heading(&section.title));
		ui.print("");
		let elements = section
			.elements
			.iter()
			.map(|element| match element {
				ParsedDocElement::Heading1 { text } => UI::format_text_heading(text),
				ParsedDocElement::DocFragment { text } => text.to_string(),
				ParsedDocElement::CommandHelp { command } => {
					UI::format_text_blockquote(&UI::format_command_help(&mut command.clone()))
				}
			})
			.collect::<Vec<String>>();
		ui.print(&elements.join("\n\n"));

		// print table of contents for main section
		if command_or_topic == MAIN_SECTION {
			ui.print("");
			ui.print(&UI::format_text_heading("More help topics"));
			ui.print("");
			ui.print(
				&parsed_doc_outline
					.iter()
					.filter_map(|section| {
						if section.id != MAIN_SECTION {
							Some(format!(
								"{}  {} {}",
								dialoguer::console::style(&section.title).underlined(),
								dialoguer::console::style("â†’").dim(),
								dialoguer::console::style(format!("help {}", section.id)).green()
							))
						} else {
							None
						}
					})
					.collect::<Vec<String>>()
					.join("\n"),
			);
		}
	} else if let Some(doc_fragment) = get_cli_doc_fragments()
		.iter()
		.find(|fragment| fragment.id == command_or_topic)
	{
		// doc fragment
		ui.print(&doc_fragment.content);
	} else if let Some(command) = CliArgs::command().find_subcommand_mut(&command_or_topic) {
		// command help
		ui.print(&UI::format_command_help(&mut command.clone()));
	} else {
		ui.print_failure(&format!("No help found for '{}'", command_or_topic));
	}

	Ok(())
}
