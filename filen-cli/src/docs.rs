//! This function generates documentation for the CLI in markdown format,
//! or prints help texts in-app.
//! It takes the outline of the documentation (none of the text!),
//! then fills in the actual documentation content from the CLI doc fragments,
//! and the command help texts generated by clap.
//! The doc fragments are doc comments in the source code marked with
//! `[cli-doc] <fragment-id>`, right next to the code they document.

use std::{collections::HashMap, collections::HashSet, path::PathBuf, sync::LazyLock};

use anyhow::{Context, Result};
use clap::CommandFactory;
use filen_macros::extract_cli_doc_fragments;

use crate::{CliArgs, ui::UI};

extract_cli_doc_fragments!();

#[derive(Debug)]
enum DocElement {
	Heading1(&'static str),
	DocFragment(&'static str),
	CommandHelp(&'static str),
}

#[derive(Debug)]
enum ParsedDocElement {
	Heading1 { text: String },
	DocFragment { text: String },
	CommandHelp { help_text: String },
}

#[derive(Debug)]
struct DocSection {
	title: &'static str,
	elements: Vec<DocElement>,
}

#[derive(Debug)]
struct ParsedDocSection {
	title: String,
	elements: Vec<ParsedDocElement>,
}

static PARSED_DOC_OUTLINE: LazyLock<Result<HashMap<&'static str, ParsedDocSection>>> =
	LazyLock::new(|| {
		let doc_outline = HashMap::from([
			(
				"usage",
				DocSection {
					title: "Usage",
					elements: vec![
						DocElement::DocFragment("main-usage"),
						DocElement::CommandHelp("help"),
						DocElement::CommandHelp("exit"),
						DocElement::Heading1("Updates"),
						DocElement::DocFragment("updates"),
						DocElement::Heading1("Mounting"),
						DocElement::CommandHelp("mount"),
					],
				},
			),
			(
				"auth",
				DocSection {
					title: "Authentication",
					elements: vec![
						DocElement::DocFragment("auth-methods"),
						DocElement::CommandHelp("export-auth-config"),
						DocElement::CommandHelp("logout"),
					],
				},
			),
			(
				"access-files",
				DocSection {
					title: "Accessing Files",
					elements: vec![
						DocElement::CommandHelp("cd"),
						DocElement::CommandHelp("ls"),
						DocElement::CommandHelp("cat"),
						DocElement::CommandHelp("head"),
						DocElement::CommandHelp("tail"),
						DocElement::CommandHelp("stat"),
						DocElement::CommandHelp("mkdir"),
						DocElement::CommandHelp("rm"),
						DocElement::CommandHelp("mv"),
						DocElement::CommandHelp("cp"),
						DocElement::CommandHelp("favorite"),
						DocElement::CommandHelp("unfavorite"),
						DocElement::CommandHelp("list-trash"),
						DocElement::CommandHelp("empty-trash"),
					],
				},
			),
		]);

		// parse doc elements
		let mut commands = CliArgs::command();
		let mut used_commands = HashSet::new();
		let cli_doc_fragments = get_cli_doc_fragments();
		let mut used_doc_fragments = HashSet::new();
		let parsed_outline = doc_outline
			.iter()
			.map(|(name, section)| {
				let parsed_elements = section
					.elements
					.iter()
					.map(|element| match element {
						DocElement::Heading1(text) => Ok(ParsedDocElement::Heading1 {
							text: text.to_string(),
						}),
						DocElement::DocFragment(fragment_id) => {
							if let Some(fragment) = cli_doc_fragments
								.iter()
								.find(|fragment| fragment.id == *fragment_id)
							{
								used_doc_fragments.insert(fragment.id.clone());
								Ok(ParsedDocElement::DocFragment {
									text: fragment.content.to_string(),
								})
							} else {
								Err(anyhow::anyhow!(
									"Doc fragment with id '{}' not found",
									fragment_id
								))
							}
						}
						DocElement::CommandHelp(command) => {
							if let Some(command) = commands.find_subcommand_mut(command) {
								used_commands.insert(command.get_name().to_string());
								Ok(ParsedDocElement::CommandHelp {
									help_text: format!("{}", command.render_long_help()),
								})
							} else {
								Err(anyhow::anyhow!(
									"Command '{}' not found in CLI structure",
									command
								))
							}
						}
					})
					.collect::<Result<Vec<ParsedDocElement>>>()
					.with_context(|| {
						format!("Failed to parse doc elements for section '{}'", name)
					})?;
				Ok((
					*name,
					ParsedDocSection {
						title: section.title.to_string(),
						elements: parsed_elements,
					},
				))
			})
			.collect::<Result<HashMap<&'static str, ParsedDocSection>>>();

		// ensure that all doc fragments and commands were used
		let unused_doc_fragments = cli_doc_fragments
			.iter()
			.map(|fragment| &fragment.id)
			.filter(|id| !used_doc_fragments.contains(id.as_str()))
			.collect::<Vec<&String>>();
		if !unused_doc_fragments.is_empty() {
			return Err(anyhow::anyhow!(
				"Some CLI doc fragments were not used in the markdown docs: {:?}",
				unused_doc_fragments
			));
		}
		let unused_commands = commands
			.get_subcommands()
			.map(|cmd| cmd.get_name().to_string())
			.filter(|name| !used_commands.contains(name))
			.collect::<Vec<String>>();
		if !unused_commands.is_empty() {
			return Err(anyhow::anyhow!(
				"Some CLI commands were not documented in the markdown docs: {:?}",
				unused_commands
			));
		}

		parsed_outline
	});
// todo: also specify here where global flags are documented?

// markdown docs

pub(crate) fn generate_markdown_docs() -> Result<()> {
	let output_dir = PathBuf::from("filen-cli-markdown-docs");
	std::fs::create_dir_all(&output_dir).context("Failed to create markdown docs output dir")?;

	PARSED_DOC_OUTLINE
		.as_ref()
		.map_err(|e| anyhow::anyhow!("Failed to parse CLI doc outline: {}", e))?
		.iter()
		.try_for_each(|(title, section)| {
			let elements = section
				.elements
				.iter()
				.map(|element| match element {
					ParsedDocElement::Heading1 { text } => format!("## {}", text),
					ParsedDocElement::DocFragment { text } => text.to_string(),
					ParsedDocElement::CommandHelp { help_text } => {
						format!("```\n{}\n```", help_text)
					}
				})
				.collect::<Vec<String>>();
			let mut markdown_content = String::new();
			markdown_content.push_str(&format!("# {}\n\n", section.title));
			markdown_content.push_str(&elements.join("\n\n"));

			std::fs::write(output_dir.join(format!("{}.md", title)), markdown_content)
				.with_context(|| format!("Failed to write markdown doc file '{}'", title))
		})?;

	Ok(())
}

// in-app docs

pub(crate) fn print_in_app_docs(ui: &mut UI, command_or_topic: String) {
	if let Some(doc_fragment) = get_cli_doc_fragments()
		.iter()
		.find(|fragment| fragment.id == command_or_topic)
	{
		// doc fragment
		ui.print(&doc_fragment.content);
	} else if let Some(command) = CliArgs::command().find_subcommand_mut(&command_or_topic) {
		// command help
		ui.print(&format!("{}", command.render_long_help()));
	} else {
		ui.print_failure(&format!("No help found for '{}'", command_or_topic));
	}
}
